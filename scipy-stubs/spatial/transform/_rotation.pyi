from collections.abc import Sequence

import numpy as np
import optype.numpy as onp
from scipy._typing import Seed

class Rotation:
    @property
    def single(self, /) -> bool: ...
    def __init__(self, /, quat: onp.ToComplex | onp.ToComplexND, normalize: bool = ..., copy: bool = ...) -> None: ...
    def __setstate_cython__(self, pyx_state: object, /) -> None: ...
    def __reduce_cython__(self, /) -> None: ...
    def __len__(self, /) -> int: ...
    def __getitem__(self, /, indexer: int | slice | onp.ToComplex | onp.ToComplexND) -> Rotation: ...
    def __mul__(self, /, other: Rotation) -> Rotation: ...
    def __pow__(self, /, n: float, modulus: int | None) -> Rotation: ...
    def as_quat(self, /, canonical: bool = ..., *, scalar_first: bool = ...) -> onp.ArrayND[np.float64]: ...
    def as_matrix(self, /) -> onp.ArrayND[np.float64]: ...
    def as_rotvec(self, /, degrees: bool = ...) -> onp.ArrayND[np.float64]: ...
    def as_euler(self, /, seq: str, degrees: bool = ...) -> onp.ArrayND[np.float64]: ...
    def as_davenport(
        self,
        /,
        axes: onp.ToComplex | onp.ToComplexND,
        order: str,
        degrees: bool = ...,
    ) -> onp.ArrayND[np.float64]: ...
    def as_mrp(self, /) -> onp.ArrayND[np.float64]: ...
    def apply(self, /, vectors: onp.ToComplex | onp.ToComplexND, inverse: bool = ...) -> onp.ArrayND[np.float64]: ...
    def inv(self, /) -> Rotation: ...
    def magnitude(self, /) -> onp.ArrayND[np.float64] | float: ...
    def approx_equal(
        self,
        /,
        other: Rotation,
        atol: float | None = None,
        degrees: bool = ...,
    ) -> onp.ArrayND[np.bool_] | bool: ...
    def mean(self, /, weights: onp.ToComplex | onp.ToComplexND | None = ...) -> Rotation: ...
    def reduce(
        self,
        /,
        left: Rotation | None = ...,
        right: Rotation | None = ...,
        return_indices: bool = ...,
    ) -> Rotation | tuple[Rotation, onp.ArrayND[np.float64], onp.ArrayND[np.float64]]: ...
    @classmethod
    def from_quat(cls, quat: onp.ToComplex | onp.ToComplexND, *, scalar_first: bool = ...) -> Rotation: ...
    @classmethod
    def from_matrix(cls, matrix: onp.ToComplex | onp.ToComplexND) -> Rotation: ...
    @classmethod
    def from_rotvec(cls, rotvec: onp.ToComplex | onp.ToComplexND, degrees: bool = ...) -> Rotation: ...
    @classmethod
    def from_euler(cls, seq: str, angles: float | onp.ToComplex | onp.ToComplexND, degrees: bool = ...) -> Rotation: ...
    @classmethod
    def from_davenport(
        cls,
        axes: onp.ToComplex | onp.ToComplexND,
        order: str,
        angles: float | onp.ToComplex | onp.ToComplexND,
        degrees: bool = ...,
    ) -> Rotation: ...
    @classmethod
    def from_mrp(cls, mrp: onp.ToComplex | onp.ToComplexND) -> Rotation: ...
    @classmethod
    def concatenate(cls, rotations: Sequence[Rotation]) -> Rotation: ...
    @classmethod
    def create_group(cls, group: str, axis: str = ...) -> Rotation: ...
    @classmethod
    def identity(cls, num: int | None = ...) -> Rotation: ...
    @classmethod
    def random(cls, num: int | None = ..., random_state: Seed | None = ...) -> Rotation: ...
    @classmethod
    def align_vectors(
        cls,
        a: onp.ToComplex | onp.ToComplexND,
        b: onp.ToComplex | onp.ToComplexND,
        weights: onp.ToComplex | onp.ToComplexND | None = ...,
        return_sensitivity: bool = ...,
    ) -> tuple[Rotation, float] | tuple[Rotation, float, onp.ArrayND[np.float64]]: ...

class Slerp:
    times: onp.ArrayND
    timedelta: onp.ArrayND
    rotations: Rotation
    rotvecs: onp.ArrayND[np.float64]
    def __init__(self, /, times: onp.ToComplex | onp.ToComplexND, rotations: Rotation) -> None: ...
    def __call__(self, /, times: onp.ToComplex | onp.ToComplexND) -> Rotation: ...
