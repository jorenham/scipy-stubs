from collections.abc import Sequence
from typing import ClassVar, Final, Literal

import numpy as np
import numpy.typing as npt
import optype.numpy as onpt
import scipy._typing as spt
from scipy._typing import Untyped, UntypedArray

__all__ = ["LinearOperator", "aslinearoperator"]

# TODO: make these all generic
class LinearOperator:
    __array_ufunc__: ClassVar[None]

    shape: tuple[int] | tuple[int, int]
    ndim: Literal[1, 2]
    @property
    def dtype(self) -> np.dtype[np.generic]: ...
    def __init__(self, dtype: npt.DTypeLike, shape: spt.AnyInt | Sequence[spt.AnyInt]) -> None: ...
    def matvec(self, x: npt.ArrayLike, /) -> UntypedArray: ...
    def rmatvec(self, x: npt.ArrayLike, /) -> UntypedArray: ...
    def matmat(self, X: npt.ArrayLike, /) -> UntypedArray: ...
    def rmatmat(self, X: npt.ArrayLike, /) -> UntypedArray: ...
    def __call__(self, x: npt.ArrayLike | LinearOperator, /) -> _ProductLinearOperator | _ScaledLinearOperator | UntypedArray: ...
    def __mul__(self, x: LinearOperator | npt.ArrayLike, /) -> _ProductLinearOperator | _ScaledLinearOperator | UntypedArray: ...
    def __truediv__(self, other: spt.AnyScalar, /) -> _ScaledLinearOperator: ...
    def dot(self, x: LinearOperator | npt.ArrayLike, /) -> _ProductLinearOperator | _ScaledLinearOperator | UntypedArray: ...
    def __matmul__(
        self,
        other: LinearOperator | onpt.CanArray[tuple[int, ...], np.dtype[np.generic]],
        /,
    ) -> _ScaledLinearOperator | UntypedArray: ...
    def __rmatmul__(
        self,
        other: LinearOperator | onpt.CanArray[tuple[int, ...], np.dtype[np.generic]],
        /,
    ) -> _ScaledLinearOperator | UntypedArray: ...
    def __rmul__(self, x: LinearOperator | npt.ArrayLike, /) -> Untyped: ...
    def __pow__(self, p: spt.AnyScalar, /) -> _PowerLinearOperator: ...
    def __add__(self, x: LinearOperator, /) -> _SumLinearOperator: ...
    def __neg__(self, /) -> _ScaledLinearOperator: ...
    def __sub__(self, x: LinearOperator, /) -> _SumLinearOperator: ...
    def adjoint(self) -> _AdjointLinearOperator: ...
    @property
    def H(self) -> _AdjointLinearOperator: ...
    def transpose(self) -> _TransposedLinearOperator: ...
    @property
    def T(self) -> _TransposedLinearOperator: ...

class _CustomLinearOperator(LinearOperator):
    args: Untyped
    def __init__(
        self,
        shape,
        matvec,
        rmatvec: Untyped | None = None,
        matmat: Untyped | None = None,
        dtype: Untyped | None = None,
        rmatmat: Untyped | None = None,
    ): ...

class _AdjointLinearOperator(LinearOperator):
    A: LinearOperator
    args: tuple[LinearOperator]
    def __init__(self, A: LinearOperator) -> None: ...

class _TransposedLinearOperator(LinearOperator):
    A: LinearOperator
    args: tuple[LinearOperator]
    def __init__(self, A: LinearOperator) -> None: ...

class _SumLinearOperator(LinearOperator):
    args: tuple[LinearOperator, LinearOperator]
    def __init__(self, A: LinearOperator, B: LinearOperator) -> None: ...

class _ProductLinearOperator(LinearOperator):
    args: tuple[LinearOperator, LinearOperator]
    def __init__(self, A: LinearOperator, B: LinearOperator) -> None: ...

class _ScaledLinearOperator(LinearOperator):
    args: tuple[LinearOperator, spt.AnyScalar]
    def __init__(self, A: LinearOperator, alpha: spt.AnyScalar) -> None: ...

class _PowerLinearOperator(LinearOperator):
    args: tuple[LinearOperator, spt.AnyInt]
    def __init__(self, A: LinearOperator, p: spt.AnyInt) -> None: ...

class MatrixLinearOperator(LinearOperator):
    A: LinearOperator
    args: tuple[LinearOperator]
    def __init__(self, A: LinearOperator) -> None: ...

class _AdjointMatrixOperator(MatrixLinearOperator):
    A: LinearOperator
    args: tuple[LinearOperator]
    shape: tuple[int, int]
    def __init__(self, adjoint: LinearOperator) -> None: ...

class IdentityOperator(LinearOperator):
    def __init__(self, shape, dtype: Untyped | None = None): ...

def aslinearoperator(A) -> Untyped: ...
