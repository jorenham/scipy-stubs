# pyright: reportUnannotatedClassAttribute=false

import abc
from collections.abc import Iterator, Sequence
from typing import Any, Final, Generic, Literal, TypeAlias, overload
from typing_extensions import Self, TypeAliasType, TypeIs, TypeVar

import numpy as np
import optype as op
import optype.numpy as onp
import optype.typing as opt
from scipy._typing import Untyped
from ._matrix import spmatrix as spmatrix

__all__ = ["SparseEfficiencyWarning", "SparseWarning", "issparse", "isspmatrix", "sparray"]

# NOTE: This is roughly speaking equivalent to `[u]int8 | [u]int16 | [u]int32 | [u]int64` (on most modern platforms)
_Int: TypeAlias = np.integer[Any]
# NOTE: NOT equivalent to `floating`! It's considered invalid to use `float16` in `scipy.sparse`.
_Float: TypeAlias = np.float32 | np.float64 | np.longdouble
# NOTE: This is (almost always) equivalent to `complex64 | complex128 | clongdouble`.
_Complex: TypeAlias = np.complexfloating[Any, Any]
# NOTE: Roughly speaking, this is equivalent to `number[Any] - float16` (the `-` denotes the set difference analogue for types)
# NOTE: This (almost always) matches `._sputils.supported_dtypes`
# NOTE: The `TypeAliasType` is used to avoid long error messages.
_Scalar = TypeAliasType("_Scalar", np.bool_ | _Int | _Float | _Complex)

_T = TypeVar("_T")
_SCT_co = TypeVar("_SCT_co", bound=_Scalar, default=_Scalar, covariant=True)

_ToShape: TypeAlias = tuple[op.CanIndex] | tuple[op.CanIndex, op.CanIndex]
_ToSparseFromPy: TypeAlias = Sequence[Sequence[_T]] | Sequence[_T]
_ToSparseFromArrayLike: TypeAlias = onp.CanArrayND[_SCT_co] | _ToSparseFromPy[_SCT_co]

_Format: TypeAlias = Literal["bsr", "coo", "csc", "csr", "dia", "dok", "lil"]

###

MAXPRINT: Final = 50

class SparseWarning(Warning): ...
class SparseFormatWarning(SparseWarning): ...
class SparseEfficiencyWarning(SparseWarning): ...

# TODO(jorenham): Generic `shape` property
# TODO(jorenham): Generic `data` attribute
class _spbase(Generic[_SCT_co]):
    __array_priority__: float = 10.1
    maxprint: Final[int | None]

    # TODO(jorenham): In `scipy>=1.15.0` `{coo,dok}_array` will support >2-D arrays
    @property
    def ndim(self, /) -> Literal[1, 2]: ...
    @property
    def shape(self, /) -> tuple[int] | tuple[int, int]: ...
    @property
    def nnz(self, /) -> int: ...
    @property
    def size(self, /) -> int: ...

    # NOTE: At runtime this isn't abstract, but returns `und` instead.
    @property
    @abc.abstractmethod
    def format(self, /) -> _Format: ...

    #
    @property
    def T(self, /) -> Self: ...
    @property
    def real(self, /) -> Self: ...
    @property
    def imag(self, /) -> Self: ...

    # NOTE: In `scipy>=1.15.0` the `maxprint` param will become keyword-only.
    @overload  # shape
    def __init__(self: _spbase[np.float64], /, arg1: _ToShape, maxprint: int | None = 50) -> None: ...
    @overload  # sparse
    def __init__(self, /, arg1: _spbase[_SCT_co], maxprint: int | None = 50) -> None: ...
    @overload  # dense array-like
    def __init__(self, /, arg1: _ToSparseFromArrayLike[_SCT_co], maxprint: int | None = 50) -> None: ...
    @overload  # dense array-like bool
    def __init__(self: _spbase[np.bool_], /, arg1: _ToSparseFromPy[bool], maxprint: int | None = 50) -> None: ...
    @overload  # dense array-like int
    def __init__(self: _spbase[np.int_], /, arg1: _ToSparseFromPy[opt.JustInt], maxprint: int | None = 50) -> None: ...
    @overload  # dense array-like float
    def __init__(self: _spbase[np.float64], /, arg1: _ToSparseFromPy[opt.Just[float]], maxprint: int | None = 50) -> None: ...
    @overload  # dense array-like cfloat
    def __init__(
        self: _spbase[np.complex128],
        /,
        arg1: _ToSparseFromPy[opt.Just[complex]],
        maxprint: int | None = 50,
    ) -> None: ...
    @overload  # dense array-like real (pyright is wrong here)
    def __init__(  # pyright: ignore[reportOverlappingOverload]
        self: _spbase[np.float64 | np.int_ | np.bool_],
        /,
        arg1: _ToSparseFromPy[float | int],
        maxprint: int | None = 50,
    ) -> None: ...
    @overload  # dense array-like complex (pyright is wrong here)
    def __init__(  # pyright: ignore[reportOverlappingOverload]
        self: _spbase[np.complex128 | np.float64 | np.int_ | np.bool_],
        /,
        arg1: _ToSparseFromPy[complex | float | int],
        maxprint: int | None = 50,
    ) -> None: ...

    #
    def __bool__(self, /) -> bool: ...
    def __iter__(self, /) -> Iterator[Untyped]: ...

    #
    def __lt__(self, other: Untyped, /) -> Untyped: ...
    def __gt__(self, other: Untyped, /) -> Untyped: ...
    def __le__(self, other: Untyped, /) -> Untyped: ...
    def __ge__(self, other: Untyped, /) -> Untyped: ...

    #
    def __neg__(self, /) -> Self: ...
    def __abs__(self, /) -> Self: ...
    def __round__(self, /, ndigits: int = 0) -> Self: ...

    #
    def __add__(self, other: Untyped, /) -> Untyped: ...
    def __radd__(self, other: Untyped, /) -> Untyped: ...
    def __sub__(self, other: Untyped, /) -> Untyped: ...
    def __rsub__(self, other: Untyped, /) -> Untyped: ...
    def __mul__(self, other: Untyped, /) -> Untyped: ...
    def __rmul__(self, other: Untyped, /) -> Untyped: ...
    def __matmul__(self, other: Untyped, /) -> Untyped: ...
    def __rmatmul__(self, other: Untyped, /) -> Untyped: ...
    def __truediv__(self, other: Untyped, /) -> Untyped: ...
    def __div__(self, other: Untyped, /) -> Untyped: ...
    def __pow__(self, other: Untyped, /) -> Untyped: ...

    #
    def nonzero(self, /) -> Untyped: ...
    def count_nonzero(self, /) -> int: ...
    def conjugate(self, /, copy: bool = True) -> Self: ...
    conj = conjugate
    def transpose(self, /, axes: Untyped | None = None, copy: bool = False) -> Self: ...

    #
    def multiply(self, /, other: Untyped) -> Untyped: ...
    def maximum(self, /, other: Untyped) -> Untyped: ...
    def minimum(self, /, other: Untyped) -> Untyped: ...
    def dot(self, /, other: Untyped) -> Untyped: ...
    def power(self, /, n: Untyped, dtype: Untyped | None = None) -> Self: ...

    #
    def diagonal(self, /, k: int = 0) -> Untyped: ...
    def trace(self, /, offset: int = 0) -> Untyped: ...
    def sum(self, /, axis: Untyped | None = None, dtype: Untyped | None = None, out: Untyped | None = None) -> Untyped: ...
    def mean(self, /, axis: Untyped | None = None, dtype: Untyped | None = None, out: Untyped | None = None) -> Untyped: ...

    #
    def copy(self, /) -> Self: ...
    def reshape(self, /, *args: Untyped, **kwargs: Untyped) -> Self: ...
    def astype(self, /, dtype: Untyped, casting: str = "unsafe", copy: bool = True) -> Untyped: ...
    def asformat(self, /, format: Untyped, copy: bool = False) -> Untyped: ...

    #
    def todense(self, /, order: Untyped | None = None, out: Untyped | None = None) -> Untyped: ...
    def toarray(self, /, order: Untyped | None = None, out: Untyped | None = None) -> Untyped: ...
    def tocsr(self, /, copy: bool = False) -> Untyped: ...
    def todok(self, /, copy: bool = False) -> Untyped: ...
    def tocoo(self, /, copy: bool = False) -> Untyped: ...
    def tolil(self, /, copy: bool = False) -> Untyped: ...
    def todia(self, /, copy: bool = False) -> Untyped: ...
    def tobsr(self, /, blocksize: tuple[int, int] | None = None, copy: bool = False) -> Untyped: ...
    def tocsc(self, /, copy: bool = False) -> Untyped: ...

    #
    def resize(self, /, shape: tuple[op.CanIndex, op.CanIndex]) -> None: ...
    def setdiag(self, /, values: Untyped, k: int = 0) -> None: ...

class sparray: ...

def issparse(x: object) -> TypeIs[_spbase]: ...
def isspmatrix(x: object) -> TypeIs[spmatrix]: ...
